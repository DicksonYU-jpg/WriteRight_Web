import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { containsHiddenMeta, containsHiddenStartMarker, unwrap } from 'i18next-subliminal';
import { store } from './store.js';
import { uninstrumentedStore } from './uninstrumentedStore.js';
import { ignoreElements, validAttributes } from './vars.js';
import { getI18nMetaFromNode } from './utils.js';
import './shims/uniqueID.js';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var currentSourceLng;
var i18n;
var ignoreMergedEleUniqueIds = [];
function setImplementation(impl) {
  i18n = impl;
}
function walk(node, func) {
  if (node.dataset && node.dataset.i18nextEditorElement === 'true') return;
  func(node);
  var instr = store.get(node.uniqueID);
  var uninstr = uninstrumentedStore.get(node.uniqueID);
  if (instr || uninstr) {
    var _node$parentElement;
    var id = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.uniqueID;
    uninstrumentedStore.remove(id, node.parentElement);
  }
  var children = node.childNodes;
  for (var i = 0; i < children.length; i++) {
    walk(children[i], func);
  }
}
function extractHiddenMeta(id, type, meta, children) {
  var _i18n, _i18n2, _i18n3;
  var invisibleMeta = meta.invisibleMeta,
    text = meta.text;
  if (!invisibleMeta || !invisibleMeta.key || !invisibleMeta.ns) return;
  if (!currentSourceLng) currentSourceLng = i18n.getSourceLng();
  return _objectSpread(_objectSpread({
    eleUniqueID: id,
    textType: type,
    children: children && children.map ? children.map(function (c) {
      return c.childIndex;
    }).join(',') : null,
    qualifiedKey: "".concat(invisibleMeta.ns, ":").concat(invisibleMeta.key)
  }, invisibleMeta), {}, {
    extractedText: text,
    i18nTargetLng: (_i18n = i18n) === null || _i18n === void 0 ? void 0 : _i18n.getLng(),
    i18nSourceLng: currentSourceLng,
    i18nRawText: _defineProperty(_defineProperty({}, "".concat(invisibleMeta.lng), invisibleMeta.source === 'translation' && i18n ? (_i18n2 = i18n) === null || _i18n2 === void 0 ? void 0 : _i18n2.getResource(invisibleMeta.lng, invisibleMeta.ns, invisibleMeta.key) : null), "".concat(currentSourceLng), invisibleMeta.source === 'translation' && i18n ? (_i18n3 = i18n) === null || _i18n3 === void 0 ? void 0 : _i18n3.getResource(currentSourceLng, invisibleMeta.ns, invisibleMeta.key) : null)
  });
}
function extractNodeMeta(id, type) {
  var _i18n4, _i18n5, _i18n6, _i18n7, _i18n8;
  var nodeMeta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var text = arguments.length > 3 ? arguments[3] : undefined;
  var children = arguments.length > 4 ? arguments[4] : undefined;
  var meta = nodeMeta[type];
  if (!meta) return;
  if (!currentSourceLng) currentSourceLng = i18n.getSourceLng();
  var i18nTargetLng = i18n.getLng();
  return {
    eleUniqueID: id,
    textType: type,
    children: children && children.map ? children.map(function (c) {
      return c.childIndex;
    }).join(',') : null,
    qualifiedKey: meta.key && (meta.ns || (_i18n4 = i18n) !== null && _i18n4 !== void 0 && _i18n4.getDefaultNS()) ? "".concat(meta.ns || ((_i18n5 = i18n) === null || _i18n5 === void 0 ? void 0 : _i18n5.getDefaultNS()), ":").concat(meta.key) : null,
    key: meta.key,
    ns: meta.ns || ((_i18n6 = i18n) === null || _i18n6 === void 0 ? void 0 : _i18n6.getDefaultNS()),
    extractedText: text,
    i18nTargetLng: i18nTargetLng,
    i18nSourceLng: currentSourceLng,
    i18nRawText: _defineProperty(_defineProperty({}, "".concat(i18nTargetLng), i18n && meta.ns && meta.key ? ((_i18n7 = i18n) === null || _i18n7 === void 0 ? void 0 : _i18n7.getResource(i18nTargetLng, meta.ns, meta.key)) || text : text), "".concat(currentSourceLng), i18n && meta.ns && meta.key ? (_i18n8 = i18n) === null || _i18n8 === void 0 ? void 0 : _i18n8.getResource(currentSourceLng, meta.ns, meta.key) : null)
  };
}
function containsOnlySpaces(str) {
  return /^\s*$/.test(str);
}
function storeIfQualifiedKey(id, subliminal, type, nodeI18nMeta, node, children, txt) {
  var stored = store.get(id);
  var storedMeta = stored && stored.keys["".concat(type)] || {};
  var typeMeta = nodeI18nMeta["".concat(type)] || {};
  if (!typeMeta.key && storedMeta.key) typeMeta.key = storedMeta.key;
  if (!typeMeta.ns && storedMeta.ns) typeMeta.ns = storedMeta.ns;
  nodeI18nMeta["".concat(type)] = typeMeta;
  var meta = extractNodeMeta(id, type, nodeI18nMeta, txt, children);
  if (meta.qualifiedKey) {
    store.save(id, null, type, meta, node, children);
    uninstrumentedStore.removeKey(id, type, node);
  } else {
    uninstrumentedStore.save(id, type, node, txt);
  }
}
function handleNode(node) {
  if (ignoreElements.indexOf(node.nodeName) > -1) return;
  var nodeI18nMeta = getI18nMetaFromNode(node);
  var usedSubliminalForText = false;
  if (node.childNodes && !ignoreMergedEleUniqueIds.includes(node.uniqueID)) {
    var merge = [];
    node.childNodes.forEach(function (child, i) {
      if (merge.length && child.nodeName !== '#text') {
        ignoreMergedEleUniqueIds.push(child.uniqueID);
        merge.push({
          childIndex: i,
          child: child
        });
      }
      if (child.nodeName !== '#text') return;
      var txt = child.textContent;
      if (containsOnlySpaces(txt)) return;
      var hasHiddenMeta = containsHiddenMeta(txt);
      var hasHiddenStartMarker = containsHiddenStartMarker(txt);
      if (hasHiddenMeta) usedSubliminalForText = true;
      if (hasHiddenStartMarker && hasHiddenMeta) {
        var meta = unwrap(txt);
        uninstrumentedStore.remove(node.uniqueID, node);
        store.save(node.uniqueID, meta.invisibleMeta, 'text', extractHiddenMeta(node.uniqueID, 'text', meta), node);
      } else if (hasHiddenStartMarker) {
        merge.push({
          childIndex: i,
          child: child,
          text: txt
        });
      } else if (merge.length && !hasHiddenMeta) {
        merge.push({
          childIndex: i,
          child: child,
          text: txt
        });
      } else if (merge.length && hasHiddenMeta) {
        merge.push({
          childIndex: i,
          child: child,
          text: txt
        });
        var _meta = unwrap(merge.reduce(function (mem, item) {
          return mem + item.text;
        }, ''));
        uninstrumentedStore.removeKey(node.uniqueID, 'html', node, txt);
        store.save(node.uniqueID, _meta.invisibleMeta, 'html', extractHiddenMeta(node.uniqueID, 'html', _meta, merge), node, merge);
        merge = [];
      }
    });
    if (!usedSubliminalForText) {
      node.childNodes.forEach(function (child, i) {
        if (merge.length && child.nodeName !== '#text') {
          ignoreMergedEleUniqueIds.push(child.uniqueID);
        }
        var txt = child.textContent;
        if (nodeI18nMeta && nodeI18nMeta.html && i < node.childNodes.length - 1) {
          merge.push({
            childIndex: i,
            child: child,
            text: txt
          });
        } else if (nodeI18nMeta && nodeI18nMeta.html && i === node.childNodes.length - 1) {
          merge.push({
            childIndex: i,
            child: child,
            text: txt
          });
          storeIfQualifiedKey(node.uniqueID, null, 'html', nodeI18nMeta, node, merge, node.innerHTML);
          merge = [];
        } else if (txt) {
          if (nodeI18nMeta && nodeI18nMeta.text) {
            storeIfQualifiedKey(node.uniqueID, null, 'text', nodeI18nMeta, node, undefined, txt);
          } else if (child.nodeName === '#text' && !containsOnlySpaces(txt)) {
            uninstrumentedStore.save(node.uniqueID, 'text', node, txt);
          }
        }
      });
    }
  }
  if (!node.getAttribute) return;
  validAttributes.forEach(function (attr) {
    var txt = node.getAttribute(attr);
    if (containsHiddenMeta(txt)) {
      var meta = unwrap(txt);
      uninstrumentedStore.removeKey(node.uniqueID, attr, node);
      store.save(node.uniqueID, meta.invisibleMeta, attr, extractHiddenMeta(node.uniqueID, "".concat(attr), meta), node);
    } else if (txt) {
      if (nodeI18nMeta && nodeI18nMeta[attr]) {
        storeIfQualifiedKey(node.uniqueID, null, attr, nodeI18nMeta, node, undefined, txt);
      } else {
        uninstrumentedStore.save(node.uniqueID, attr, node, txt);
      }
    }
  });
}
function parseTree(node) {
  currentSourceLng = undefined;
  walk(node, handleNode);
  store.clean();
  ignoreMergedEleUniqueIds = [];
  return store.data;
}

export { extractNodeMeta, parseTree, setImplementation };
